#!/usr/bin/env ruby
# Copyright (c) 2013, Autumn Perrault, et al. All rights reserved.
# This free software is distributed under the FreeBSD license (LICENSE.md).

require 'English'

# Forbid root.
if ENV.include? 'USER'
  if ENV['USER'] == 'root'
    puts "It is forbidden to run Auto as the root user!"
    exit 1
  end
end

$LOAD_PATH.unshift File.expand_path(File.join(File.dirname(__FILE__), '..', 'lib')) # Add the Auto libraries to LOAD_PATH

# Require necessary libraries.
require 'slop'
require 'auto'
require 'auto/verbosity'

# Parse options.
opts = Slop.parse(:banner => "Usage: #$PROGRAM_NAME [options]") do
  on :h, :help, 'Display this help message.' do
    puts self
    exit 0
  end
  on :v, :version, 'Display version and exit.' do
    puts <<-EOV
Auto #{Auto::FULLVERSION}, by the Auto Project

http://auto.autoproj.org
    EOV
    exit 0
  end

  on :d, :debug, 'Execute with debugging enabled.'
  on :f, :foreground, 'Do not fork into the background.'
  on :c, :conf=, 'Specify a particular configuration file.'
  on :V, :verbose, 'Increase verbosity of debugging (more uses the more verbose).' do
    $VERBOSITY += 1
  end
end

# Begin start up.
puts "* Auto #{Auto::VERSION} starting...".bold

# Enter main directory.
Dir.chdir(File.join(File.dirname(__FILE__), '..'))

# Create an instance of Auto.
begin
  $m = Auto::Bot.new(opts)
  status = $m.init
rescue => e
  puts 'An error occurred!'.red.bold
  puts e
  puts e.backtrace
end

# Check our status.
if status
  time = Time.now
  puts "* Auto started @ #{time}".green.bold
  $m.log.info("Auto started @ #{time}")
else
  puts "Start up failed! Read above for errors.".red.bold
  exit 1
end
STARTTIME = time.freeze

# We survived? We survived! Fork into the background if not in debug or foreground.
unless opts.debug? or opts.foreground?
  puts "Forking into the background...".bold
  
  # Direct all incoming data on STDIN and outgoing data on STDOUT/STDERR to /dev/null.
  $stdin  = File.open '/dev/null'
  $stdout = $stderr = File.open '/dev/null', 'w'
  # Fork and retrieve the PID.
  pid     = fork

  # Save it to auto.pid.
  unless pid.nil?
    File.open('auto.pid', 'w') { |io| io.puts pid }
    exit 0
  end
end

# Signals
sig = {
  'TERM' => proc { $m.terminate('Caught termination signal') },
  'INT'  => proc { $m.terminate('Ctrl-C pressed') },
  'HUP'  => proc { $m.conf.rehash }
}
sig.delete 'HUP' if Auto.windows?
sig.each { |signal, prc| Signal.trap(signal) { prc.call } }

begin
  $m.start
rescue => e
  $m.error("FATAL EXCEPTION: #{e}", true, e.backtrace)
end

# vim: set ts=4 sts=2 sw=2 et:
