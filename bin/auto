#!/usr/bin/env ruby
# Auto 4
# Copyright (c) 2013, Auto Project
# Distributed under the terms of the FreeBSD license (LICENSE.md).

gitdir = File.join(File.dirname(__FILE__), '..', '.git')
if Dir.exists? gitdir
  REVISION = File.open(File.join(gitdir, 'refs', 'heads', 'master')).first[0..7]
end
$:.unshift File.expand_path(File.join(File.dirname(__FILE__), '..', 'lib'))

# Require necessary libraries.
require 'optparse'
require 'auto'

# Parse options.
mopts = { 'debug' => false, 'foreground' => false, 'json' => false }
OptionParser.new do |opts|

  # Set banner.
  opts.banner = "Usage: #$0 [options]"

  # Set separator.
  opts.separator ''
  opts.separator "Options:"

  # Configuration file.
  opts.on('-c', '--config', "Specify a configuration file path other than conf/auto.{yml,json}") do |path|
    mopts['altconf'] = path
  end

  # Debug flag.
  opts.on('-d', '--debug', "Execute in debug mode.") { |v| mopts['debug'] = true }

  # Foreground flag.
  opts.on('-f', '--foreground', "Do not fork into the background.") { |v| mopts['foreground'] = true }

  # JSON flag.
  opts.on('-j', '--json', "Use JavaScript Object Notation (JSON) for configuration. (Default file is conf/auto.json)") do |v|
    mopts['json'] = true
  end

  # Version flag.
  opts.on('-v', '--version', "Print version and exit.") do |v|
    puts <<VERSION
Auto #{Auto::VERSION} #{Auto::CODENAME}
#{"Git revision: #{REVISION}\n" if defined? REVISION}
http://auto.autoproj.org
VERSION
    exit 0
  end

end.parse!

# Begin start up.
puts "* Auto #{Auto::VERSION} starting...".bold

# Enter main directory.
Dir.chdir(File.join(File.dirname(__FILE__), '..'))

# Create an instance of Auto.
begin
  $m = Auto::Bot.new(mopts)
  status = $m.init
rescue => e
  puts 'An error occurred!'.red.bold
  puts e
  puts e.backtrace
end

# Check our status.
if status
  time = Time.now
  puts "* Auto started @ #{time}".green.bold
  $m.log.info("Auto started @ #{time}")
else
  puts "Start up failed! Read above for errors.".red.bold
  exit 1
end
STARTTIME = time

# We survived? We survived! Fork into the background if not in debug or foreground.
unless mopts['debug'] or mopts['foreground']
  
  puts "Forking into the background...".bold
  
  # Direct all incoming data on STDIN and outgoing data on STDOUT/STDERR to /dev/null.
  $stdin  = File.open '/dev/null'
  $stdout = File.open '/dev/null', 'w'
  $stderr = File.open '/dev/null', 'w'
  # Fork and retrieve the PID.
  pid     = fork


  # Save it to auto.pid.
  unless pid.nil?
    File.open('auto.pid', 'w') { |io| io.puts pid }
    exit 0
  end
end

### SIGNALS ###

# Catch SIGTERM
Signal.trap('TERM') { $m.terminate("Caught SIGTERM") }

# Catch SIGINT
Signal.trap('INT') { $m.terminate("Caught Ctrl-C") }

# Catch SIGHUP (rehash)
Signal.trap('HUP') { $m.conf.rehash! }

### END SIGNALS ###

# The following should capture all exceptions that are not otherwise caught:
begin
  # Start the bot.
  $m.start
rescue => e
  $m.error("FATAL EXCEPTION: #{e}", true, e.backtrace)
end

# vim: set ts=4 sts=2 sw=2 et:
