# Auto 4
# Copyright (c) 2013, Auto Project
# Distributed under the terms of the FreeBSD license (LICENSE.md).

require 'colored'
require 'highline'
require 'yaml'

$S = '>>>'.blue

# namespace Auto
module Auto

  # A library for configuration generation. It depends upon the highline gem.
  #
  # @version 1.00
  # @author swarley
  # @author noxgirl
  #
  # @!attribute hl
  #   @return [HighLine] HighLine instance.
  #
  # @!attribute conf
  #   @return [Hash{}] The configuration hash.
  class Configure

    VERSION = '1.00'.freeze

    attr_accessor :hl, :conf

    # Produce a new instance of Auto::Configure.
    def initialize
      
      # Produce a new instance of HighLine.
      @hl   = HighLine.new
      # Prepare for configuration.
      @conf = Hash.new

    end

    # Initiate configuration.
    def start
      
      greeting = <<-EOM
Greetings! ^.^

I am going to assist you in configuring your installation of Auto. :) I suggest
that, if you're not already reading it, you consult the installation guide:
https://github.com/Auto/Auto/wiki/Install-Guide

When specifying lists, separate elements by commas.

Remember, if you need additional help, you're free to use the mailing list at
https://groups.google.com/group/autobot-talk, or to join the official IRC
channel at #auto on irc.freenode.net. :)

Let us begin!
      EOM
      puts greeting.yellow.bold

      conf_libraries

      # Uncomment dump and remove the puts when Auto::Configure is done.
      #dump
      puts @conf

    end

    # Configure libraries.
    def conf_libraries
      puts ">>> Currently, the only available library is the IRC library. I will load this automatically.".cyan.bold
      @conf['libraries'] = ['irc']

      conf_irclib
    end

    # Configure the IRC library.
    def conf_irclib

      # Create the configuration hash.
      @conf['irc'] = {}

      # Add the first server.
      conf_add_server

      # Add subsequent servers.
      another = @hl.agree("#$S Would you like to add another IRC server?  ") { |q| q.default = 'n' }
      while another
        conf_add_server
        another = @hl.agree("#$S Would you like to add another IRC server?  ") { |q| q.default = 'n' }
      end

    end

    # Add an IRC server.
    def conf_add_server

      # We need a name.
      name = @hl.ask("#$S What is the name of this IRC server?  ")
      while @conf['irc'].include? name
        puts "You've already specified that server. Use a different name.".red.bold
        name = @hl.ask("#$S What is the name of this IRC server?")
      end

      # We need an address.
      address = @hl.ask("#$S What is the address of <%= color('#{name}', :blue, :bold) %>?  ")

      # And a port.
      port = @hl.ask("#$S What is the port of <%= color('#{name}', :blue, :bold) %>?  ", Integer) { |q| q.default = 6667 }

      # Does it use SSL?
      ssl = @hl.agree("#$S Does <%= color('#{address}:#{port}', :blue, :bold) %> use SSL?  ") { |q| q.default = 'n' }
      
      # What nickname(s) should we use?
      nicks = @hl.ask("#$S What nicknames should I use on <%= color('#{name}', :blue, :bold) %> (list in descending priority)?  ",
                      lambda { |str| str.split(/,\s*/) }) do |q|
        q.default  = 'auto'
      end
      nicksvalid = true
      nicks.each { |n| nicksvalid = false unless n =~ /^[\w\d\[\]\{\}\^\-\_\`]+$/ }
      until nicksvalid
        puts "You entered an invalid nickname. Try again.".red.bold
        nicks = @hl.ask("#$S What nicknames should I use on <%= color('#{name}', :blue, :bold) %> (list in descending priority)?  ",
                      lambda { |str| str.split(/,\s*/) }) do |q|
          q.default  = 'auto'
        end
        nicksvalid = true
        nicks.each { |n| nicksvalid = false unless n =~ /^[\w\d\[\]\{\}\^\-\_\`]+$/ }
      end

      # What username?
      user = @hl.ask("#$S What username should I use on <%= color('#{name}', :blue, :bold) %>?  ") { |q| q.default = 'auto' }


      # Save the data.
      @conf['irc'][name] = {
        'address'  => address,
        'port'     => port,
        'useSSL'   => ssl,
        'nickname' => nicks,
        'username' => user
      }
      
    end

    # Dump configuration.
    def dump

      # A sanity check.
      if @conf.empty?
        puts "Configuration is inexplicably empty: aborting.".red.bold
        exit 1
      end

      # Produce file.
      data = <<-EOD
# Configuration file generated by auto-conf
# version #{Auto::Configure::VERSION}
# at #{Time.now}

#{YAML.dump(@conf)}
      EOD
      
      # Produce message.
      final = <<-EOM
OK! Your configuration file is ready! :D

I just need to know one last thing: where to write this fabulous configuration.

By default, I will write this to <YOUR_HOME_DIRECTORY>/.config/autobot/auto.yml,
which is perfect for you if you're using the 'autobot' gem, because this is the
standard file for which the gem will look when executed.

However, if you are running a standalone installation, you probably want to
write this to your conf/ directory as auto.yml (if you're running #$0 from the
main directory, "conf/auto.yml"), as the standalone Auto will look for that
when it is executed.

In any event, you are free to write this anywhere you please. Just remember
that if it is not a default path, you must specify it when running Auto:

$ auto --config=path/to/config/file.yml

Caution: The specified file will be overwritten if it already exists.
      EOM
      puts final.green.bold

      # Save our directories of interest into easily accessible variables.
      configdir = File.join(Dir.home, '.config')
      autodir   = File.join(Dir.home, '.config', 'autobot')

      # Ensure that said directories exist regardless of any other conditions.
      unless Dir.exists? configdir
        puts "~ Creating missing directory #{configdir}".magenta
        Dir.mkdir configdir
      end
      unless Dir.exists? autodir
        puts "~ Creating missing directory #{autodir}".magenta
        Dir.mkdir autodir
      end

      # Ask for a path.
      path = @hl.ask("#$S To where should the configuration be written?  ", Pathname) do |q|
        
        # Default is ~/.config/autobot/auto.yml
        q.default  = File.join(autodir, 'auto.yml')

        # A proc to validate the path
        q.validate = proc do |path|
          return false unless path =~ /\.yml$/ # it should end in .yml
          return false unless Dir.exists? File.dirname(path) # the directory should exist
          # We should be able to write to the file:
          begin
            File.open(path, 'w') { |io| io.puts "# Configuration file generated by auto-conf" }
          rescue => e
            return false
          end
          true
        end

        # A proc to be called in the event of an invalid path
        q.responses[:not_valid] = proc do
          
          # Choose an emergency file in ~/.config/autobot/ to which to save.
          emerg_file = File.join(autodir, "auto.yml.#{Time.now.strftime('%s')}")
          puts "Invalid path! Attempting to write to #{emerg_file}.....".red
          File.open(path, 'w') do |io| 
            io.write data
          end

        end

      end # ask()

      File.open(path, 'w') { |io| io.write data } # Dump the data into the file.

      # We're done.
      puts "I have successfully written your configuration file to #{path}. Thank you for using Auto.".green.bold

    end

  end # class Configure

end # module Auto

# This will fix a certain undesirable output.
#
# HighLine::Question#append_default appends an ugly manifestation of the
# default answer.
#
# This destroys that provided by HighLine::Question and in lieu uses a prettier
# one.
class HighLine
  class Question
    def append_default
      str = ''
      if @default == 'y'
        str = "<%= color('Y', :green) %>/<%= color('n', :red) %>"
      elsif @default == 'n'
        str = "<%= color('y', :green) %>/<%= color('N', :red) %>"
      else
        str = "<%= color('#@default', :bold) %>"
      end

      if @question =~ /([\t ]+)\Z/
        @question << "[#{str}]#{$1}"
      elsif @question == ""
        @question << "[#{str}]  "
      elsif @question[-1, 1] == "\n"
        @question[-2, 0] =  "  [#{str}]"
      else
        @question << "  [#{str}]"
      end
    end
  end
end

# vim: set ts=4 sts=2 sw=2 et:
